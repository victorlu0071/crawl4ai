# Content from: https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html

### Navigation
  * [Index](https://www.riverbankcomputing.com/static/Docs/PyQt6/genindex.html "General index")
  * [Classes](https://www.riverbankcomputing.com/static/Docs/PyQt6/sip-classes.html "Index of all classes") |
  * [Modules](https://www.riverbankcomputing.com/static/Docs/PyQt6/module_index.html "Index of all modules") |
  * [PyQt Documentation v6.9.0](https://www.riverbankcomputing.com/static/Docs/PyQt6/index.html) »
  * [Using Qt Designer](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html)


# Using Qt Designer[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#using-qt-designer "Link to this heading")
Qt Designer is the Qt tool for designing and building graphical user interfaces. It allows you to design widgets, dialogs or complete main windows using on-screen forms and a simple drag-and-drop interface. It has the ability to preview your designs to ensure they work as you intended, and to allow you to prototype them with your users, before you have to write any code.
Qt Designer uses XML `.ui` files to store designs and does not generate any code itself. Qt includes the `uic` utility that generates the C++ code that creates the user interface. Qt also includes the `QUiLoader` class that allows an application to load a `.ui` file and to create the corresponding user interface dynamically.
PyQt6 does not wrap the `QUiLoader` class but instead includes the [uic](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/uic/uic-module.html) Python module. Like `QUiLoader` this module can load `.ui` files to create a user interface dynamically. Like the **uic** utility it can also generate the Python code that will create the user interface. PyQt6’s **pyuic6** utility is a command line interface to the [uic](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/uic/uic-module.html) module. Both are described in detail in the following sections.
## Using the Generated Code[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#using-the-generated-code "Link to this heading")
The code that is generated has an identical structure to that generated by Qt’s `uic` and can be used in the same way.
The code is structured as a single class that is derived from the Python `object` type. The name of the class is the name of the toplevel object set in Designer with `Ui_` prepended. (In the C++ version the class is defined in the `Ui` namespace.) We refer to this class as the _form class_.
The class contains a method called `setupUi()`. This takes a single argument which is the widget in which the user interface is created. The type of this argument (typically [QDialog](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/qtwidgets/qdialog.html), [QWidget](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/qtwidgets/qwidget.html) or [QMainWindow](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/qtwidgets/qmainwindow.html)) is set in Designer. We refer to this type as the _Qt base class_.
In the following examples we assume that a `.ui` file has been created containing a dialog and the name of the [QDialog](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/qtwidgets/qdialog.html) object is `ImageDialog`. We also assume that the name of the file containing the generated Python code is `ui_imagedialog.py`. The generated code can then be used in a number of ways.
The first example shows the direct approach where we simply create a simple application to create the dialog:
```
importsys
fromPyQt6.QtWidgetsimport QApplication, QDialog
fromui_imagedialogimport Ui_ImageDialog
app = QApplication(sys.argv)
window = QDialog()
ui = Ui_ImageDialog()
ui.setupUi(window)
window.show()
sys.exit(app.exec())

```

The second example shows the single inheritance approach where we sub-class [QDialog](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/qtwidgets/qdialog.html) and set up the user interface in the `__init__()` method:
```
fromPyQt6.QtWidgetsimport QDialog
fromui_imagedialogimport Ui_ImageDialog
classImageDialog(QDialog):
  def__init__(self):
    super().__init__()
    # Set up the user interface from Designer.
    self.ui = Ui_ImageDialog()
    self.ui.setupUi(self)
    # Make some local modifications.
    self.ui.colorDepthCombo.addItem("2 colors (1 bit per pixel)")
    # Connect up the buttons.
    self.ui.okButton.clicked.connect(self.accept)
    self.ui.cancelButton.clicked.connect(self.reject)

```

The final example shows the multiple inheritance approach:
```
fromPyQt6.QtGuiimport QDialog
fromui_imagedialogimport Ui_ImageDialog
classImageDialog(QDialog, Ui_ImageDialog):
  def__init__(self):
    super().__init__()
    # Set up the user interface from Designer.
    self.setupUi(self)
    # Make some local modifications.
    self.colorDepthCombo.addItem("2 colors (1 bit per pixel)")
    # Connect up the buttons.
    self.okButton.clicked.connect(self.accept)
    self.cancelButton.clicked.connect(self.reject)

```

For a full description see the Qt Designer Manual in the Qt Documentation.
## **pyuic6**[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#pyuic6 "Link to this heading")
The **pyuic6** utility is a command line interface to the [uic](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/uic/uic-module.html) module. The command has the following syntax:
```
pyuic6 [options] .ui-file

```

If `.ui_file` is a file then that file is converted. If it is a directory then every file with a `.ui` extension in the directory is converted.
The full set of command line options is: 

-h, --help[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#cmdoption-pyuic6-h "Link to this definition")
    
A help message is written to `stdout`. 

-V, --version[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#cmdoption-pyuic6-V "Link to this definition")
    
The version number is written to `stdout`. 

-d, --debug[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#cmdoption-pyuic6-d "Link to this definition")
    
Show debug output. 

-i <N>, --indent <N>[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#cmdoption-pyuic6-i "Link to this definition")
    
The Python code is generated using an indentation of `<N>` spaces. If `<N>` is 0 then a tab is used. The default is 4. 

-o <FILE>, --output <FILE>[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#cmdoption-pyuic6-o "Link to this definition")
    
If a single file is being converted then the Python code generated is written to the file `<FILE>`. If `<FILE>` is `-` then it is written to `stdout`. If a directory is converted then the generatee code is written to this directory. 

-p, --preview[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#cmdoption-pyuic6-p "Link to this definition")
    
The GUI is created dynamically and displayed. No Python code is generated. 

-w <N>, --max-workers <N>[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#cmdoption-pyuic6-w "Link to this definition")
    
A maximum of N worker processes are used when converting a directory. The default is 0. 

-x, --execute[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#cmdoption-pyuic6-x "Link to this definition")
    
The generated Python code includes a small amount of additional code that creates and displays the GUI when it is executes as a standalone application.
Note that code generated by **pyuic6** is not guaranteed to be compatible with earlier versions of PyQt6. However, it is guaranteed to be compatible with later versions. If you have no control over the version of PyQt6 the users of your application are using then you should run **pyuic6** , or call [`compileUi()`](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/uic/uic-module.html#PyQt6.uic.compileUi "PyQt6.uic.compileUi"), as part of your installation process. Another alternative would be to distribute the `.ui` files (perhaps as part of a resource file) and have your application load them dynamically.
## Writing Qt Designer Plugins[¶](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#writing-qt-designer-plugins "Link to this heading")
Qt Designer can be extended by writing plugins. Normally this is done using C++ but PyQt6 also allows you to write plugins in Python. Most of the time a plugin is used to expose a custom widget to Designer so that it appears in Designer’s widget box just like any other widget. It is possibe to change the widget’s properties and to connect its signals and slots.
It is also possible to add new functionality to Designer. See the Qt documentation for the full details. Here we will concentrate on describing how to write custom widgets in Python.
The process of integrating Python custom widgets with Designer is very similar to that used with widget written using C++. However, there are particular issues that have to be addressed.
  * Designer needs to have a C++ plugin that conforms to the interface defined by the `QDesignerCustomWidgetInterface` class. (If the plugin exposes more than one custom widget then it must conform to the interface defined by the `QDesignerCustomWidgetCollectionInterface` class.) In addition the plugin class must sub-class [QObject](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/qtcore/qobject.html) as well as the interface class. PyQt6 does not allow Python classes to be sub-classed from more than one Qt class.
  * Designer can only connect Qt signals and slots. It has no understanding of Python signals or callables.
  * Designer can only edit Qt properties that represent C++ types. It has no understanding of Python attributes or Python types.


PyQt6 provides the following components and features to resolve these issues as simply as possible.
  * PyQt6’s QtDesigner module includes additional classes (all of which have a `QPy` prefix) that are already sub-classed from the necessary Qt classes. This avoids the need to sub-class from more than one Qt class in Python. For example, where a C++ custom widget plugin would sub-class from [QObject](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/qtcore/qobject.html) and `QDesignerCustomWidgetInterface`, a Python custom widget plugin would instead sub-class from [QPyDesignerCustomWidgetPlugin](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/qtdesigner/qpydesignercustomwidgetplugin.html).
  * PyQt6 installs a C++ plugin in Designer’s plugin directory. It conforms to the interface defined by the `QDesignerCustomWidgetCollectionInterface` class. It searches a configurable set of directories looking for Python plugins that implement a class sub-classed from [QPyDesignerCustomWidgetPlugin](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/qtdesigner/qpydesignercustomwidgetplugin.html). Each class that is found is instantiated and the instance created is added to the custom widget collection.
The `PYQTDESIGNERPATH` environment variable specifies the set of directories to search for plugins. Directory names are separated by a path separator (a semi-colon on Windows and a colon on other platforms). If a directory name is empty (ie. there are consecutive path separators or a leading or trailing path separator) then a set of default directories is automatically inserted at that point. The default directories are the `python` subdirectory of each directory that Designer searches for its own plugins. If the environment variable is not set then only the default directories are searched. If a file’s basename does not end with `plugin` then it is ignored.
  * A Python custom widget may define new Qt signals using pyqtSignal.
  * A Python method may be defined as a new Qt slot by using the [pyqtSlot()](https://www.riverbankcomputing.com/static/Docs/PyQt6/api/qtcore/qtcore-module.html#pyqtSlot) decorator.
  * A new Qt property may be defined using the pyqtProperty function.


Note that the ability to define new Qt signals, slots and properties from Python is potentially useful to plugins conforming to any plugin interface and not just that used by Designer.
For a simple but complete and fully documented example of a custom widget that defines new Qt signals, slots and properties, and its plugin, look in the `examples/designer/plugins` directory of the PyQt6 source package. The `widgets` subdirectory contains the `pydemo.py` custom widget and the `python` subdirectory contains its `pydemoplugin.py` plugin.
### [Table of Contents](https://www.riverbankcomputing.com/static/Docs/PyQt6/index.html)
  * [Using Qt Designer](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html)
    * [Using the Generated Code](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#using-the-generated-code)
    * [**pyuic6**](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#pyuic6)
    * [Writing Qt Designer Plugins](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html#writing-qt-designer-plugins)


#### Previous topic
[Things to be Aware Of](https://www.riverbankcomputing.com/static/Docs/PyQt6/gotchas.html "previous chapter")
#### Next topic
[Support for Pickling](https://www.riverbankcomputing.com/static/Docs/PyQt6/pickle.html "next chapter")
### Quick search
### Navigation
  * [Index](https://www.riverbankcomputing.com/static/Docs/PyQt6/genindex.html "General index")
  * [Classes](https://www.riverbankcomputing.com/static/Docs/PyQt6/sip-classes.html "Index of all classes") |
  * [Modules](https://www.riverbankcomputing.com/static/Docs/PyQt6/module_index.html "Index of all modules") |
  * [PyQt Documentation v6.9.0](https://www.riverbankcomputing.com/static/Docs/PyQt6/index.html) »
  * [Using Qt Designer](https://www.riverbankcomputing.com/static/Docs/PyQt6/designer.html)


© Copyright 2025, Riverbank Computing Limited, The Qt Company. Created using [Sphinx](https://www.sphinx-doc.org/) 8.2.3. 
